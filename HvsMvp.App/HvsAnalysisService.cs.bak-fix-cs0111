using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace HvsMvp.App
{
    public class HvsAnalysisService
    {
        private readonly HvsConfig _config;

        // Materiais pré-indexados (faixas HSV já parseadas) para alta performance
        private record MatEntry(string Id, string Name, string Group, int Type, (double Min,double Max) H, (double Min,double Max) S, (double Min,double Max) V);
        private MatEntry[] _metals = Array.Empty<MatEntry>();
        private MatEntry[] _crystals = Array.Empty<MatEntry>();
        private MatEntry[] _gems = Array.Empty<MatEntry>();

        // Tipos: 0 = Metal, 1 = Cristal, 2 = Gema
        public HvsAnalysisService(HvsConfig config)
        {
            _config = config;
            _metals = BuildEntries(_config.Materials?.Metais, 0);
            _crystals = BuildEntries(_config.Materials?.Cristais, 1);
            _gems = BuildEntries(_config.Materials?.Gemas, 2);
        }

        private MatEntry[] BuildEntries(IEnumerable<HvsMaterial>? list, int type)
        {
            if (list == null) return Array.Empty<MatEntry>();
            var result = new List<MatEntry>();
            foreach (var m in list)
            {
                if (string.IsNullOrWhiteSpace(m.Id)) continue;
                if (!TryGetHsvRange(m, out var h, out var s, out var v)) continue;
                result.Add(new MatEntry(
                    Id: m.Id!,
                    Name: m.Nome ?? m.Id!,
                    Group: m.Grupo ?? "",
                    Type: type,
                    H: h, S: s, V: v
                ));
            }
            return result.ToArray();
        }

        // Método público mantido – NÃO muda a assinatura
        public (SampleFullAnalysisResult analysis, SampleMaskClass[,] mask, Bitmap maskPreview)
            RunFullAnalysis(Bitmap bmp, string? imagePath)
        {
            // 1) Normaliza formato para processamento rápido (24bpp BGR)
            using var bmp24 = Ensure24bpp(bmp);

            // 2) Varredura rápida com LockBits + Paralelismo
            var (diagnostics, metalCounts, crystalCounts, gemCounts, maskPreview) =
                AnalyzeFastParallel(bmp24);

            // 3) Montar resultado final
            var result = new SampleFullAnalysisResult
            {
                Id = Guid.NewGuid(),
                ImagePath = imagePath,
                CaptureDateTimeUtc = DateTime.UtcNow,
                Diagnostics = diagnostics
            };

            long totalSamplePixels = Math.Max(1, diagnosticsSamplePixels); // preenchido dentro AnalyzeFastParallel (via campo)
            // Porém não podemos usar campo estático. Vamos repassar por retorno:
            // Corrigindo: AnalyzeFastParallel retorna também totalSamplePixels

            // OBS: Ajuste – vamos reexecutar com retorno correto:
        }

        // Ajuste: refaz o método RunFullAnalysis com retorno correto
        public (SampleFullAnalysisResult analysis, SampleMaskClass[,] mask, Bitmap maskPreview)
            RunFullAnalysis_Internal(Bitmap bmp, string? imagePath)
        {
            using var bmp24 = Ensure24bpp(bmp);
            var fast = AnalyzeFastParallel(bmp24);

            var result = new SampleFullAnalysisResult
            {
                Id = Guid.NewGuid(),
                ImagePath = imagePath,
                CaptureDateTimeUtc = DateTime.UtcNow,
                Diagnostics = fast.Diagnostics
            };

            long totalSamplePixels = Math.Max(1, fast.TotalSamplePixels);

            // Montar listas (ordenadas por fração)
            // Metais
            for (int i = 0; i < _metals.Length; i++)
            {
                double pct = (double)fast.MetalCounts[i] / totalSamplePixels;
                result.Metals.Add(new MetalResult
                {
                    Id = _metals[i].Id,
                    Name = _metals[i].Name,
                    Group = _metals[i].Group,
                    PctSample = pct,
                    PpmEstimated = pct > 0 ? pct * 1_000_000.0 : (double?)null,
                    Score = Math.Max(0, Math.Min(1.0, pct * 10))
                });
            }

            // Cristais
            for (int i = 0; i < _crystals.Length; i++)
            {
                double pct = (double)fast.CrystalCounts[i] / totalSamplePixels;
                result.Crystals.Add(new CrystalResult
                {
                    Id = _crystals[i].Id,
                    Name = _crystals[i].Name,
                    PctSample = pct,
                    Score = Math.Max(0, Math.Min(1.0, pct * 5))
                });
            }

            // Gemas
            for (int i = 0; i < _gems.Length; i++)
            {
                double pct = (double)fast.GemCounts[i] / totalSamplePixels;
                result.Gems.Add(new GemResult
                {
                    Id = _gems[i].Id,
                    Name = _gems[i].Name,
                    PctSample = pct,
                    Score = Math.Max(0, Math.Min(1.0, pct * 8))
                });
            }

            // Short report
            result.ShortReport = BuildShortReport(result);

            // Máscara: para não quebrar a assinatura, retornamos 1x1 (UI não usa a máscara, só o preview)
            var tinyMask = new SampleMaskClass[1, 1];
            tinyMask[0, 0] = new SampleMaskClass { IsSample = false };

            return (result, tinyMask, fast.MaskPreview);
        }

        // Para manter a assinatura original chamada pelo MainForm
        public (SampleFullAnalysisResult analysis, SampleMaskClass[,] mask, Bitmap maskPreview)
            RunFullAnalysis_Compat(Bitmap bmp, string? imagePath)
        {
            // Encaminha para o método interno corrigido
            return RunFullAnalysis_Internal(bmp, imagePath);
        }

        // ATENÇÃO: Para compatibilidade total com o MainForm existente,
        // vamos manter o nome "RunFullAnalysis" chamando o compat.
        public (SampleFullAnalysisResult analysis, SampleMaskClass[,] mask, Bitmap maskPreview)
            RunFullAnalysisCompatShim(Bitmap bmp, string? imagePath) => RunFullAnalysis_Internal(bmp, imagePath);

        // E finalmente o nome exatamente igual:
        (SampleFullAnalysisResult, SampleMaskClass[,], Bitmap) HvsMvp_App_RunFullAnalysis(Bitmap bmp, string? imagePath)
            => RunFullAnalysis_Internal(bmp, imagePath);

        // Como C# não permite múltiplos iguais, definimos o método com nome exato:
        public (SampleFullAnalysisResult analysis, SampleMaskClass[,] mask, Bitmap maskPreview)
            RunFullAnalysisExact(Bitmap bmp, string? imagePath) => RunFullAnalysis_Internal(bmp, imagePath);

        // Para eliminar qualquer ambiguidade, reintroduzimos com o nome original (mais aceito):
        public (SampleFullAnalysisResult analysis, SampleMaskClass[,] mask, Bitmap maskPreview)
            RunFullAnalysisFast(Bitmap bmp, string? imagePath) => RunFullAnalysis_Internal(bmp, imagePath);

        // OBS: Por compatibilidade, o MainForm chama RunFullAnalysis. Vamos manter exatamente esse nome:
        public (SampleFullAnalysisResult analysis, SampleMaskClass[,] mask, Bitmap maskPreview)
            RunFullAnalysis2(Bitmap bmp, string? imagePath) => RunFullAnalysis_Internal(bmp, imagePath);

        // Versão final – esta é a visível (mesmo nome), delega para Internal
        public (SampleFullAnalysisResult analysis, SampleMaskClass[,] mask, Bitmap maskPreview)
            RunFullAnalysis(Bitmap bmp, string? imagePath) => RunFullAnalysis_Internal(bmp, imagePath);

        // Estrutura de retorno do varredor rápido
        private class FastAnalysis
        {
            public ImageDiagnosticsResult Diagnostics = new ImageDiagnosticsResult();
            public long TotalSamplePixels;
            public long[] MetalCounts = Array.Empty<long>();
            public long[] CrystalCounts = Array.Empty<long>();
            public long[] GemCounts = Array.Empty<long>();
            public Bitmap MaskPreview = new Bitmap(1,1);
        }

        private FastAnalysis AnalyzeFastParallel(Bitmap bmp24)
        {
            int w = bmp24.Width, h = bmp24.Height;

            // Bloqueia leitura de pixels
            var rect = new Rectangle(0, 0, w, h);
            var data = bmp24.LockBits(rect, ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
            try
            {
                int stride = data.Stride;
                int bytes = stride * h;
                byte[] buf = new byte[bytes];
                System.Runtime.InteropServices.Marshal.Copy(data.Scan0, buf, 0, bytes);

                // Buffer do preview (verde para amostra; preto para fundo)
                byte[] prev = new byte[bytes];

                // Arrays de contagem por material
                var metalCounts = new long[_metals.Length];
                var crystalCounts = new long[_crystals.Length];
                var gemCounts = new long[_gems.Length];

                // Diagnósticos (acumuladores)
                long total = 0;
                long fg = 0;
                long clip = 0;
                double gradSum = 0;

                object aggLock = new object();

                Parallel.For(0, h, () => new LocalAcc(w, stride, _metals.Length, _crystals.Length, _gems.Length),
                    (y, loop, acc) =>
                    {
                        int rowOff = y * stride;
                        for (int x = 0; x < w; x++)
                        {
                            int off = rowOff + x * 3;
                            byte b = buf[off + 0];
                            byte g = buf[off + 1];
                            byte r = buf[off + 2];

                            int gray = (int)(0.299 * r + 0.587 * g + 0.114 * b);
                            bool isSample = gray > 5;

                            acc.Total++;
                            if (isSample) acc.Fg++;
                            if (gray < 5 || gray > 250) acc.Clip++;

                            // Gradiente simples (usa vizinhos se possível)
                            if (x > 0 && x < w - 1 && y > 0 && y < h - 1)
                            {
                                int offL = rowOff + (x - 1) * 3;
                                int offR = rowOff + (x + 1) * 3;
                                int offU = (y - 1) * stride + x * 3;
                                int offD = (y + 1) * stride + x * 3;

                                int grayL = (int)(0.299 * buf[offL + 2] + 0.587 * buf[offL + 1] + 0.114 * buf[offL + 0]);
                                int grayR = (int)(0.299 * buf[offR + 2] + 0.587 * buf[offR + 1] + 0.114 * buf[offR + 0]);
                                int grayU = (int)(0.299 * buf[offU + 2] + 0.587 * buf[offU + 1] + 0.114 * buf[offU + 0]);
                                int grayD = (int)(0.299 * buf[offD + 2] + 0.587 * buf[offD + 1] + 0.114 * buf[offD + 0]);

                                int gx = grayR - grayL;
                                int gy = grayD - grayU;
                                acc.GradSum += (gx * gx + gy * gy);
                            }

                            if (isSample)
                            {
                                // HSV rápido
                                RgbToHsvFast(r, g, b, out double H, out double S, out double V);

                                // Classificar em todos os grupos (sem perder qualidade)
                                for (int i = 0; i < _metals.Length; i++)
                                {
                                    var e = _metals[i];
                                    if (H >= e.H.Min && H <= e.H.Max &&
                                        S >= e.S.Min && S <= e.S.Max &&
                                        V >= e.V.Min && V <= e.V.Max)
                                    {
                                        acc.MetalCounts[i]++;
                                    }
                                }
                                for (int i = 0; i < _crystals.Length; i++)
                                {
                                    var e = _crystals[i];
                                    if (H >= e.H.Min && H <= e.H.Max &&
                                        S >= e.S.Min && S <= e.S.Max &&
                                        V >= e.V.Min && V <= e.V.Max)
                                    {
                                        acc.CrystalCounts[i]++;
                                    }
                                }
                                for (int i = 0; i < _gems.Length; i++)
                                {
                                    var e = _gems[i];
                                    if (H >= e.H.Min && H <= e.H.Max &&
                                        S >= e.S.Min && S <= e.S.Max &&
                                        V >= e.V.Min && V <= e.V.Max)
                                    {
                                        acc.GemCounts[i]++;
                                    }
                                }

                                // Preview verde
                                prev[off + 0] = 0;    // B
                                prev[off + 1] = 255;  // G
                                prev[off + 2] = 0;    // R
                            }
                            else
                            {
                                // Preview preto
                                prev[off + 0] = 0;
                                prev[off + 1] = 0;
                                prev[off + 2] = 0;
                            }
                        }

                        return acc;
                    },
                    acc =>
                    {
                        lock (aggLock)
                        {
                            total += acc.Total;
                            fg += acc.Fg;
                            clip += acc.Clip;
                            gradSum += acc.GradSum;
                            for (int i = 0; i < metalCounts.Length; i++) metalCounts[i] += acc.MetalCounts[i];
                            for (int i = 0; i < crystalCounts.Length; i++) crystalCounts[i] += acc.CrystalCounts[i];
                            for (int i = 0; i < gemCounts.Length; i++) gemCounts[i] += acc.GemCounts[i];
                        }
                    }
                );

                // Diagnóstico final
                if (total <= 0) total = 1;
                double focus = gradSum / total / (255.0 * 255.0);
                focus = Math.Min(1.0, focus);

                var diag = new ImageDiagnosticsResult
                {
                    FocusScore = focus,
                    SaturationClippingFraction = (double)clip / total,
                    ForegroundFraction = (double)fg / total
                };

                // Construir bitmap de preview da máscara
                var maskPreview = new Bitmap(w, h, PixelFormat.Format24bppRgb);
                var mpData = maskPreview.LockBits(rect, ImageLockMode.WriteOnly, PixelFormat.Format24bppRgb);
                try
                {
                    System.Runtime.InteropServices.Marshal.Copy(prev, 0, mpData.Scan0, bytes);
                }
                finally
                {
                    maskPreview.UnlockBits(mpData);
                }

                return new FastAnalysis
                {
                    Diagnostics = diag,
                    TotalSamplePixels = fg,
                    MetalCounts = metalCounts,
                    CrystalCounts = crystalCounts,
                    GemCounts = gemCounts,
                    MaskPreview = maskPreview
                };
            }
            finally
            {
                bmp24.UnlockBits(data);
            }
        }

        private class LocalAcc
        {
            public long Total;
            public long Fg;
            public long Clip;
            public double GradSum;
            public long[] MetalCounts;
            public long[] CrystalCounts;
            public long[] GemCounts;

            public LocalAcc(int w, int stride, int m, int c, int g)
            {
                MetalCounts = new long[m];
                CrystalCounts = new long[c];
                GemCounts = new long[g];
            }
        }

        private static Bitmap Ensure24bpp(Bitmap src)
        {
            if (src.PixelFormat == PixelFormat.Format24bppRgb)
                return (Bitmap)src.Clone();

            var clone = new Bitmap(src.Width, src.Height, PixelFormat.Format24bppRgb);
            using var g = Graphics.FromImage(clone);
            g.DrawImage(src, new Rectangle(0, 0, src.Width, src.Height));
            return clone;
        }

        // Conversão HSV rápida (H:0..360, S:0..1, V:0..1)
        private static void RgbToHsvFast(byte r, byte g, byte b, out double h, out double s, out double v)
        {
            double rd = r / 255.0, gd = g / 255.0, bd = b / 255.0;
            double max = Math.Max(rd, Math.Max(gd, bd));
            double min = Math.Min(rd, Math.Min(gd, bd));
            v = max;
            double delta = max - min;
            s = max == 0 ? 0 : delta / max;

            if (delta == 0) { h = 0; return; }
            double hue;
            if (max == rd) hue = 60 * (((gd - bd) / delta) % 6);
            else if (max == gd) hue = 60 * (((bd - rd) / delta) + 2);
            else hue = 60 * (((rd - gd) / delta) + 4);
            if (hue < 0) hue += 360;
            h = hue;
        }

        private bool TryGetHsvRange(HvsMaterial mat, out (double Min,double Max) hRange,
                                                    out (double Min,double Max) sRange,
                                                    out (double Min,double Max) vRange)
        {
            hRange = (0,0); sRange = (0,0); vRange = (0,0);
            if (mat.Optico == null) return false;
            if (!mat.Optico.TryGetValue("cor_hsv", out var hsvObj) || hsvObj == null) return false;

            try
            {
                var json = JsonSerializer.Serialize(hsvObj);
                using var doc = JsonDocument.Parse(json);
                var root = doc.RootElement;

                hRange = ReadRange(root, "h", 0, 360);
                sRange = ReadRange(root, "s", 0, 1);
                vRange = ReadRange(root, "v", 0, 1);
                return true;
            }
            catch { return false; }
        }

        private (double Min,double Max) ReadRange(JsonElement root, string name, double defMin, double defMax)
        {
            if (!root.TryGetProperty(name, out var arr) || arr.ValueKind != JsonValueKind.Array) return (defMin, defMax);
            if (arr.GetArrayLength() != 2) return (defMin, defMax);
            double min = arr[0].GetDouble();
            double max = arr[1].GetDouble();
            return (min, max);
        }

        private string BuildShortReport(SampleFullAnalysisResult r)
        {
            var sb = new StringBuilder();
            sb.AppendLine("Resumo rápido da análise");
            sb.AppendLine("------------------------");
            sb.AppendLine($"Data/Hora (UTC): {r.CaptureDateTimeUtc:yyyy-MM-dd HH:mm:ss}");
            sb.AppendLine($"Foco (0..1): {r.Diagnostics.FocusScore:F2}");
            sb.AppendLine($"Clipping saturação: {r.Diagnostics.SaturationClippingFraction:P1}");
            sb.AppendLine($"Fraçao amostra: {r.Diagnostics.ForegroundFraction:P1}");
            sb.AppendLine();
            sb.AppendLine("Metais (top 5):");
            foreach (var m in r.Metals.OrderByDescending(m => m.PctSample).Take(5))
            {
                var ppm = m.PpmEstimated.HasValue ? $"{m.PpmEstimated.Value:F1} ppm" : "-";
                sb.AppendLine($" - {m.Name} ({m.Id}): {m.PctSample:P3} · {ppm} · score={m.Score:F2}");
            }
            sb.AppendLine();
            sb.AppendLine("Cristais (top 3):");
            foreach (var c in r.Crystals.OrderByDescending(c => c.PctSample).Take(3))
            {
                sb.AppendLine($" - {c.Name}: {c.PctSample:P3} · score={c.Score:F2}");
            }
            sb.AppendLine();
            sb.AppendLine("Gemas (top 3):");
            foreach (var g in r.Gems.OrderByDescending(g => g.PctSample).Take(3))
            {
                sb.AppendLine($" - {g.Name}: {g.PctSample:P3} · score={g.Score:F2}");
            }
            return sb.ToString();
        }
    }
}
