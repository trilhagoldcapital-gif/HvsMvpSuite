using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace HvsMvp.App
{
    public class HvsAnalysisService
    {
        private readonly HvsConfig _config;

        // Entrada de material pré-indexado (faixas normalizadas)
        private record MatEntry(
            string Id, string Name, string Group, int Type,
            (double Min,double Max) H, bool HWrap,
            (double Min,double Max) S,
            (double Min,double Max) V,
            double HMid, double SHalf, double VHalf
        );

        private MatEntry[] _metals = Array.Empty<MatEntry>();
        private MatEntry[] _crystals = Array.Empty<MatEntry>();
        private MatEntry[] _gems = Array.Empty<MatEntry>();

        // Configurações defensivas
        private readonly double _minSat = 0.10;      // ignora pixels com saturação baixa
        private readonly double _minVal = 0.08;      // ignora pixels muito escuros
        private readonly double _maxVal = 0.98;      // ignora pixels saturados/brancos
        private readonly double _minScorePixel = 0.35; // limiar mínimo de confiança por pixel

        // Tipos: 0 = Metal, 1 = Cristal, 2 = Gema
        public HvsAnalysisService(HvsConfig config)
        {
            _config = config;

            _metals   = BuildEntries(_config.Materials?.Metais,   0);
            _crystals = BuildEntries(_config.Materials?.Cristais, 1);
            _gems     = BuildEntries(_config.Materials?.Gemas,    2);
        }

        private MatEntry[] BuildEntries(IEnumerable<HvsMaterial>? list, int type)
        {
            if (list == null) return Array.Empty<MatEntry>();
            var result = new List<MatEntry>();

            foreach (var m in list)
            {
                if (string.IsNullOrWhiteSpace(m.Id)) continue;
                if (!TryGetHsvRangeNormalized(m, out var h, out var s, out var v, out bool hWrap)) continue;

                double hMid = MidHue(h.Min, h.Max, hWrap);
                double sHalf = Math.Max(1e-6, (s.Max - s.Min) / 2.0);
                double vHalf = Math.max(1e-6, (v.Max - v.Min) / 2.0);

                result.Add(new MatEntry(
                    Id: m.Id!,
                    Name: m.Nome ?? m.Id!,
                    Group: m.Grupo ?? "",
                    Type: type,
                    H: h, HWrap: hWrap,
                    S: s, V: v,
                    HMid: hMid, SHalf: sHalf, VHalf: vHalf
                ));
            }
            return result.ToArray();
        }

        // Único método público usado pelo MainForm
        public (SampleFullAnalysisResult analysis, SampleMaskClass[,] mask, Bitmap maskPreview)
            RunFullAnalysis(Bitmap bmp, string? imagePath)
        {
            using var bmp24 = Ensure24bpp(bmp);
            var fast = AnalyzeFastParallel(bmp24);

            var result = new SampleFullAnalysisResult
            {
                Id = Guid.NewGuid(),
                ImagePath = imagePath,
                CaptureDateTimeUtc = DateTime.UtcNow,
                Diagnostics = fast.Diagnostics
            };

            long totalSamplePixels = Math.Max(1, fast.TotalSamplePixels);

            // Metais
            for (int i = 0; i < _metals.Length; i++)
            {
                double pct = (double)fast.MetalCounts[i] / totalSamplePixels;
                result.Metals.Add(new MetalResult
                {
                    Id = _metals[i].Id,
                    Name = _metals[i].Name,
                    Group = _metals[i].Group,
                    PctSample = pct,
                    PpmEstimated = pct > 0 ? pct * 1_000_000.0 : (double?)null,
                    Score = Math.Max(0, Math.Min(1.0, pct * 10))
                });
            }

            // Cristais
            for (int i = 0; i < _crystals.Length; i++)
            {
                double pct = (double)fast.CrystalCounts[i] / totalSamplePixels;
                result.Crystals.Add(new CrystalResult
                {
                    Id = _crystals[i].Id,
                    Name = _crystals[i].Name,
                    PctSample = pct,
                    Score = Math.Max(0, Math.Min(1.0, pct * 5))
                });
            }

            // Gemas
            for (int i = 0; i < _gems.Length; i++)
            {
                double pct = (double)fast.GemCounts[i] / totalSamplePixels;
                result.Gems.Add(new GemResult
                {
                    Id = _gems[i].Id,
                    Name = _gems[i].Name,
                    PctSample = pct,
                    Score = Math.Max(0, Math.Min(1.0, pct * 8))
                });
            }

            result.ShortReport = BuildShortReport(result);

            // Máscara mínima (UI usa só preview)
            var tinyMask = new SampleMaskClass[1, 1];
            tinyMask[0, 0] = new SampleMaskClass { IsSample = false };

            return (result, tinyMask, fast.MaskPreview);
        }

        private class FastAnalysis
        {
            public ImageDiagnosticsResult Diagnostics = new ImageDiagnosticsResult();
            public long TotalSamplePixels;
            public long[] MetalCounts = Array.Empty<long>();
            public long[] CrystalCounts = Array.Empty<long>();
            public long[] GemCounts = Array.Empty<long>();
            public Bitmap MaskPreview = new Bitmap(1,1);
        }

        private FastAnalysis AnalyzeFastParallel(Bitmap bmp24)
        {
            int w = bmp24.Width, h = bmp24.Height;

            var rect = new Rectangle(0, 0, w, h);
            var data = bmp24.LockBits(rect, ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
            try
            {
                int stride = data.Stride;
                int bytes = stride * h;
                byte[] buf = new byte[bytes];
                System.Runtime.InteropServices.Marshal.Copy(data.Scan0, buf, 0, bytes);

                byte[] prev = new byte[bytes];

                var metalCounts = new long[_metals.Length];
                var crystalCounts = new long[_crystals.Length];
                var gemCounts = new long[_gems.Length];

                long total = 0;
                long fg = 0;
                long clip = 0;
                double gradSum = 0;

                object aggLock = new object();

                Parallel.For(0, h, () => new LocalAcc(_metals.Length, _crystals.Length, _gems.Length, stride),
                    (y, loop, acc) =>
                    {
                        int rowOff = y * stride;
                        for (int x = 0; x < w; x++)
                        {
                            int off = rowOff + x * 3;
                            byte b = buf[off + 0];
                            byte g = buf[off + 1];
                            byte r = buf[off + 2];

                            int gray = (int)(0.299 * r + 0.587 * g + 0.114 * b);
                            bool isSample = gray > 5;

                            acc.Total++;
                            if (isSample) acc.Fg++;
                            if (gray < 5 || gray > 250) acc.Clip++;

                            // Gradiente simples
                            if (x > 0 && x < w - 1 && y > 0 && y < h - 1)
                            {
                                int offL = rowOff + (x - 1) * 3;
                                int offR = rowOff + (x + 1) * 3;
                                int offU = (y - 1) * stride + x * 3;
                                int offD = (y + 1) * stride + x * 3;

                                int grayL = (int)(0.299 * buf[offL + 2] + 0.587 * buf[offL + 1] + 0.114 * buf[offL + 0]);
                                int grayR = (int)(0.299 * buf[offR + 2] + 0.587 * buf[offR + 1] + 0.114 * buf[offR + 0]);
                                int grayU = (int)(0.299 * buf[offU + 2] + 0.587 * buf[offU + 1] + 0.114 * buf[offU + 0]);
                                int grayD = (int)(0.299 * buf[offD + 2] + 0.587 * buf[offD + 1] + 0.114 * buf[offD + 0]);

                                int gx = grayR - grayL;
                                int gy = grayD - grayU;
                                acc.GradSum += (gx * gx + gy * gy);
                            }

                            if (isSample)
                            {
                                // HSV
                                RgbToHsvFast(r, g, b, out double H, out double S, out double V);

                                // Regras anti-ruído
                                if (S < _minSat || V < _minVal || V > _maxVal)
                                {
                                    // Preview: preto
                                    prev[off + 0] = 0; prev[off + 1] = 0; prev[off + 2] = 0;
                                    continue;
                                }

                                // Escolher APENAS UM material (top-1) entre todos (metais+cristais+gemas)
                                double bestScore = 0;
                                int bestType = -1;
                                int bestIndex = -1;

                                // Avalia todos
                                EvaluateList(H, S, V, _metals,   ref bestScore, ref bestType, ref bestIndex, 0);
                                EvaluateList(H, S, V, _crystals, ref bestScore, ref bestType, ref bestIndex, 1);
                                EvaluateList(H, S, V, _gems,     ref bestScore, ref bestType, ref bestIndex, 2);

                                if (bestScore >= _minScorePixel && bestIndex >= 0)
                                {
                                    if (bestType == 0) acc.MetalCounts[bestIndex]++;
                                    else if (bestType == 1) acc.CrystalCounts[bestIndex]++;
                                    else if (bestType == 2) acc.GemCounts[bestIndex]++;

                                    // Preview verde apenas se classificado com confiança
                                    prev[off + 0] = 0; prev[off + 1] = 255; prev[off + 2] = 0;
                                }
                                else
                                {
                                    // Sem classificação confiável: preto
                                    prev[off + 0] = 0; prev[off + 1] = 0; prev[off + 2] = 0;
                                }
                            }
                            else
                            {
                                // fundo
                                prev[off + 0] = 0; prev[off + 1] = 0; prev[off + 2] = 0;
                            }
                        }

                        return acc;
                    },
                    acc =>
                    {
                        lock (aggLock)
                        {
                            total += acc.Total;
                            fg += acc.Fg;
                            clip += acc.Clip;
                            gradSum += acc.GradSum;
                            for (int i = 0; i < metalCounts.Length; i++) metalCounts[i] += acc.MetalCounts[i];
                            for (int i = 0; i < crystalCounts.Length; i++) crystalCounts[i] += acc.CrystalCounts[i];
                            for (int i = 0; i < gemCounts.Length; i++) gemCounts[i] += acc.GemCounts[i];
                        }
                    }
                );

                if (total <= 0) total = 1;
                double focus = gradSum / total / (255.0 * 255.0);
                focus = Math.Min(1.0, focus);

                var diag = new ImageDiagnosticsResult
                {
                    FocusScore = focus,
                    SaturationClippingFraction = (double)clip / total,
                    ForegroundFraction = (double)fg / total
                };

                var maskPreview = new Bitmap(w, h, PixelFormat.Format24bppRgb);
                var mpData = maskPreview.LockBits(rect, ImageLockMode.WriteOnly, PixelFormat.Format24bppRgb);
                try
                {
                    System.Runtime.InteropServices.Marshal.Copy(prev, 0, mpData.Scan0, bytes);
                }
                finally
                {
                    maskPreview.UnlockBits(mpData);
                }

                return new FastAnalysis
                {
                    Diagnostics = diag,
                    TotalSamplePixels = fg,
                    MetalCounts = metalCounts,
                    CrystalCounts = crystalCounts,
                    GemCounts = gemCounts,
                    MaskPreview = maskPreview
                };
            }
            finally
            {
                bmp24.UnlockBits(data);
            }
        }

        private class LocalAcc
        {
            public long Total;
            public long Fg;
            public long Clip;
            public double GradSum;
            public long[] MetalCounts;
            public long[] CrystalCounts;
            public long[] GemCounts;

            public LocalAcc(int m, int c, int g, int stride)
            {
                MetalCounts = new long[m];
                CrystalCounts = new long[c];
                GemCounts = new long[g];
            }
        }

        private static Bitmap Ensure24bpp(Bitmap src)
        {
            if (src.PixelFormat == PixelFormat.Format24bppRgb)
                return (Bitmap)src.Clone();

            var clone = new Bitmap(src.Width, src.Height, PixelFormat.Format24bppRgb);
            using var g = Graphics.FromImage(clone);
            g.DrawImage(src, new Rectangle(0, 0, src.Width, src.Height));
            return clone;
        }

        // Conversão HSV rápida (H:0..360, S:0..1, V:0..1)
        private static void RgbToHsvFast(byte r, byte g, byte b, out double h, out double s, out double v)
        {
            double rd = r / 255.0, gd = g / 255.0, bd = b / 255.0;
            double max = Math.Max(rd, Math.Max(gd, bd));
            double min = Math.Min(rd, Math.Min(gd, bd));
            v = max;
            double delta = max - min;
            s = max == 0 ? 0 : delta / max;

            if (delta == 0) { h = 0; return; }
            double hue;
            if (max == rd) hue = 60 * (((gd - bd) / delta) % 6);
            else if (max == gd) hue = 60 * (((bd - rd) / delta) + 2);
            else hue = 60 * (((rd - gd) / delta) + 4);
            if (hue < 0) hue += 360;
            h = hue;
        }

        // Avalia um conjunto e atualiza bestScore/bestType/bestIndex
        private void EvaluateList(double H, double S, double V, MatEntry[] arr, ref double bestScore, ref int bestType, ref int bestIndex, int typeVal)
        {
            for (int i = 0; i < arr.Length; i++)
            {
                var e = arr[i];

                // Checagem de inclusão nas faixas básicas (respeitando wrap de H)
                if (!InHueRange(H, e.H, e.HWrap)) continue;
                if (S < e.S.Min || S > e.S.Max) continue;
                if (V < e.V.Min || V > e.V.Max) continue;

                // Score por distância normalizada aos centros
                double sh = HueScore(H, e.H, e.HWrap, e.HMid);
                double ss = RangeScore(S, e.S, e.SHalf);
                double sv = RangeScore(V, e.V, e.VHalf);

                double score = (sh + ss + sv) / 3.0;

                if (score > bestScore)
                {
                    bestScore = score;
                    bestType = typeVal;
                    bestIndex = i;
                }
            }
        }

        private static bool InHueRange(double h, (double Min,double Max) r, bool wrap)
        {
            if (!wrap) return h >= r.Min && h <= r.Max;
            // wrap: intervalo cruza 360->0, então match se >= Min OU <= Max
            return (h >= r.Min) || (h <= r.Max);
        }

        private static double HueScore(double h, (double Min,double Max) r, bool wrap, double hMid)
        {
            // Distância angular mínima ao centro do intervalo, normalizada pelo semi-largura
            double halfSpan = wrap ? (((360 - r.Min) + r.Max) / 2.0) : ((r.Max - r.Min) / 2.0);
            if (halfSpan <= 0) halfSpan = 1;
            double d = AngularDistance(h, hMid);
            double norm = Math.Max(0, 1 - (d / halfSpan));
            return Math.Min(1, norm);
        }

        private static double AngularDistance(double a, double b)
        {
            double d = Math.Abs(a - b) % 360.0;
            return d > 180 ? 360 - d : d;
        }

        private static double RangeScore(double v, (double Min,double Max) r, double half)
        {
            if (v < r.Min || v > r.Max) return 0;
            double mid = (r.Min + r.Max) / 2.0;
            if (half <= 0) half = (r.Max - r.Min) / 2.0;
            if (half <= 0) return 1;
            double dist = Math.Abs(v - mid) / half;
            return Math.Max(0, 1 - dist);
        }

        private static double MidHue(double min, double max, bool wrap)
        {
            if (!wrap) return (min + max) / 2.0;
            // exemplo wrap: [350, 20] → centro ≈ 5 graus
            double span = (360 - min) + max;
            double half = span / 2.0;
            double mid = (min + half) % 360.0;
            return mid;
        }

        // Lê e normaliza faixas HSV: aceita S/V em [0..1] OU [0..100], H em [0..360]
        private bool TryGetHsvRangeNormalized(HvsMaterial mat,
            out (double Min,double Max) hRange, out (double Min,double Max) sRange, out (double Min,double Max) vRange, out bool hWrap)
        {
            hRange = (0,0); sRange = (0,0); vRange = (0,0); hWrap = false;

            if (mat.Optico == null) return false;
            if (!mat.Optico.TryGetValue("cor_hsv", out var hsvObj) || hsvObj == null) return false;

            try
            {
                var json = JsonSerializer.Serialize(hsvObj);
                using var doc = JsonDocument.Parse(json);
                var root = doc.RootElement;

                var h = ReadRange(root, "h", 0, 360);
                var s = ReadRange(root, "s", 0, 1);
                var v = ReadRange(root, "v", 0, 1);

                // Normaliza S/V se estiverem em 0..100
                if (s.Max > 1.0 || s.Min > 1.0) { s = (s.Min / 100.0, s.Max / 100.0); }
                if (v.Max > 1.0 || v.Min > 1.0) { v = (v.Min / 100.0, v.Max / 100.0); }

                // Corrige H wrap (ex.: [350, 20])
                hWrap = h.Min > h.Max;
                hRange = h; sRange = s; vRange = v;
                return true;
            }
            catch
            {
                return false;
            }
        }

        private (double Min,double Max) ReadRange(JsonElement root, string name, double defMin, double defMax)
        {
            if (!root.TryGetProperty(name, out var arr) || arr.ValueKind != JsonValueKind.Array) return (defMin, defMax);
            if (arr.GetArrayLength() != 2) return (defMin, defMax);
            double min = arr[0].GetDouble();
            double max = arr[1].GetDouble();
            return (min, max);
        }

        private string BuildShortReport(SampleFullAnalysisResult r)
        {
            var sb = new StringBuilder();
            sb.AppendLine("Resumo rápido da análise");
            sb.AppendLine("------------------------");
            sb.AppendLine($"Data/Hora (UTC): {r.CaptureDateTimeUtc:yyyy-MM-dd HH:mm:ss}");
            sb.AppendLine($"Foco (0..1): {r.Diagnostics.FocusScore:F2}");
            sb.AppendLine($"Clipping saturação: {r.Diagnostics.SaturationClippingFraction:P1}");
            sb.AppendLine($"Fraçao amostra: {r.Diagnostics.ForegroundFraction:P1}");
            sb.AppendLine();
            sb.AppendLine("Metais (top 5):");
            foreach (var m in r.Metals.OrderByDescending(m => m.PctSample).Take(5))
            {
                var ppm = m.PpmEstimated.HasValue ? $"{m.PpmEstimated.Value:F1} ppm" : "-";
                sb.AppendLine($" - {m.Name} ({m.Id}): {m.PctSample:P3} · {ppm} · score={m.Score:F2}");
            }
            sb.AppendLine();
            sb.AppendLine("Cristais (top 3):");
            foreach (var c in r.Crystals.OrderByDescending(c => c.PctSample).Take(3))
            {
                sb.AppendLine($" - {c.Name}: {c.PctSample:P3} · score={c.Score:F2}");
            }
            sb.AppendLine();
            sb.AppendLine("Gemas (top 3):");
            foreach (var g in r.Gems.OrderByDescending(g => g.PctSample).Take(3))
            {
                sb.AppendLine($" - {g.Name}: {g.PctSample:P3} · score={g.Score:F2}");
            }
            return sb.ToString();
        }
    }
}
